//! Audit-specific test suite for the 0BTC Wire project
//!
//! This module contains tests specifically designed for the external security audit.
//! These tests focus on security properties, edge cases, and performance characteristics.

#[cfg(test)]
mod security_properties;

#[cfg(test)]
mod edge_cases;

#[cfg(test)]
mod performance;

#[cfg(test)]
mod fuzz;

#[cfg(test)]
mod integration;

/// Common utilities for audit tests
pub mod utils {
    use plonky2::field::goldilocks_field::GoldilocksField;
    use plonky2::plonk::config::PoseidonGoldilocksConfig;
    use wire_lib::core::proof::SerializableProof;
    use wire_lib::core::{PublicKeyTarget, SignatureTarget, UTXOTarget};
    use wire_lib::errors::WireResult;

    /// Generate a test key pair
    pub fn generate_test_key_pair() -> (u64, (u64, u64)) {
        // For testing purposes, we use a fixed key pair
        // In a real scenario, this would be randomly generated
        let private_key = 0x1234567890abcdef;
        let public_key_x = 0xfedcba0987654321;
        let public_key_y = 0x1122334455667788;

        (private_key, (public_key_x, public_key_y))
    }

    /// Generate a test signature
    pub fn generate_test_signature() -> (u64, u64, u64) {
        // For testing purposes, we use a fixed signature
        // In a real scenario, this would be generated based on the message and private key
        let r_x = 0xaabbccddeeff0011;
        let r_y = 0x2233445566778899;
        let s = 0x99887766554433221100;

        (r_x, r_y, s)
    }

    /// Generate a test UTXO
    pub fn generate_test_utxo() -> (Vec<u8>, Vec<u8>, u64, Vec<u8>) {
        // For testing purposes, we use a fixed UTXO
        // In a real scenario, this would be generated based on the transaction
        let owner_pubkey_hash = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];
        let asset_id = vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
        let amount = 1_000_000; // 0.01 BTC in satoshis
        let salt = vec![0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88];

        (owner_pubkey_hash, asset_id, amount, salt)
    }

    /// Generate a test attestation
    pub fn generate_test_attestation() -> (Vec<u8>, u64, u64, (u64, u64, u64)) {
        // For testing purposes, we use a fixed attestation
        // In a real scenario, this would be generated by the custodian
        let recipient_pk_hash = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];
        let amount = 1_000_000; // 0.01 BTC in satoshis
        let deposit_nonce = 42;
        let signature = generate_test_signature();

        (recipient_pk_hash, amount, deposit_nonce, signature)
    }

    /// Verify a proof and return the result
    pub fn verify_proof(proof: &SerializableProof, circuit_type: &str) -> WireResult<()> {
        match circuit_type {
            "wrapped-mint" => {
                wire_lib::circuits::wrapped_asset_mint::WrappedAssetMintCircuit::verify_proof(proof)
            }
            "wrapped-burn" => {
                wire_lib::circuits::wrapped_asset_burn::WrappedAssetBurnCircuit::verify_proof(proof)
            }
            "transfer" => wire_lib::circuits::transfer::TransferCircuit::verify_proof(proof),
            _ => Err(wire_lib::errors::WireError::InvalidCircuitType(format!(
                "Unknown circuit type: {}",
                circuit_type
            ))),
        }
    }

    /// Measure execution time of a function
    pub fn measure_time<F, T>(f: F) -> (T, std::time::Duration)
    where
        F: FnOnce() -> T,
    {
        let start = std::time::Instant::now();
        let result = f();
        let duration = start.elapsed();

        (result, duration)
    }

    /// Measure memory usage of a function
    pub fn measure_memory<F, T>(f: F) -> (T, usize)
    where
        F: FnOnce() -> T,
    {
        // This is a simplified version that doesn't actually measure memory
        // In a real implementation, this would use platform-specific APIs
        // or a memory profiling library
        let result = f();

        // Return a placeholder memory usage
        (result, 0)
    }
}
